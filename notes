The source folder or "src" folder is where we will write all of our svelte code .the main.js file is used by svelte so that it can kick start the project,
the app.svelte file is a svelte component and a root component however this is just a dummy component and is always available whenever you first make a
new svelte project.

The .gitignore is for version controll and this is used so that we don't need to upload certain files onto git like node modules, the public builds etc ...

The package.json file is used so that we know what packages we need to install for the project.

We also have a readme file for some helpful tips on how to use svelte.

The rollup.config.js is like a webpack file where all the code is already done to watch out file, configure our code and bundles to our output files
and no changes are needed for it.

When we build our web app, svelte compiles our code and dumps it in the public folder

First of all we need to install the dependencies (command:- npm install)
To view all your changes you need to setup a local development server (command:- npm run dev)

components are building blocks of a website and can be put together and output to the dom for creating a whole website

Examples for a component:

1 - header
2 - footer
3 - contact from
4 - modal
5 - pop up

ETC ...

The .svelte is the extension

App.svelte folder:

Inside each component we have 3 different things 

script for component logic, html that is injected in the DOM and the style for applying styling to our html

The main.js file is used to kick start the app, it has the code that runs first and then set everything up for used.

"
import App from './App.svelte';

const app = new App({
	target: document.body,
	props: {
		name: 'world'
	}
});

export default app;
"

The above code is a basic example for how the svelte targets and injects into the dom or part of the DOM.

The "new App({ ... })" is called an instance and inside this instance is where you will find and object.

generally we use the body tag as most of the content is kept there in an html page


We always pass in function references rather then invoking them in run time

sample of function reference:-
<button on:click="{changeColor}">Button Name</button>

sample of function invoking:-
<button on:click="{changeColor()}">Button Name</button> ------------->  WE DO NOT DO THIS OKAY 

One-way binding:
This is where the change isn't reflected inside the input box
example:
<input type="text" name="" id="" on:input="{typeColor}">


Two-way binding:
This is where the change is reflected on the input box
example:
<input type="text" value="{beltColor}" on:input="{typeColor}">




"Loops"
We use loops to cycle through some data like an array and output an html template for each 
item in that array of data.

example:-

this is a sample array of some random data
"
let items = [
		{name: 'Yoshi', belt_color: 'black', age: '28', id: '1'},
		{name: 'Mario', belt_color: 'orange', age: '28', id: '2'},
		{name: 'Luigi', belt_color: 'red', age: '28', id: '3'},
		{name: 'Toad', belt_color: 'yellow', age: '28', id: '4'}
	];
"
Now we will use an each loop, similarly like PHP's foreach loop to loop through each item
and display dynamically rather then hard coding it manually.

"
{#each items as item}
	<div>
			<h1>{item.name}</h1>
			<p>
				Belt color is {item.belt_color} and I am {item.age} years old
			</p>
		</div>
{/each}
"
the 'items' array is now passing its data in the 'item' variable as 1 single item 
the html is used as a template to show the data using css and other means.


We can also pass in a key property inside the each loops

"
{#each items as item (items.id)}
	<div>
			<h1>{item.name}</h1>
			<p>
				Belt color is {item.belt_color} and I am {item.age} years old
			</p>
		</div>
{/each}
"

the output will be the same but now svelte is linking each set of data in the array
with each div container to make it unique. This is useful for manipulating data.

We can also add and 'else clause' with the each loop and this will also function like 
a conditional statement where if the above sameple array was empty then it will fire
the else condition and display a different result.



"Inline Event Handlers:" 

we can write inline functions like for deleting a record and bind that function in a button
and when ever the on:click event is triggered, the function will be called and the code inside
the function will fire.

we can write inline function as shown below:
"
<button on:click={ ()=> deleteButton(item.name) }>Delete</button>
"

notice that whenever we write a function we have to use the {} braces but in the inline we 
don't need to.

Now to delete a record, we can check if the data is correct and then filter it out the required data	
we need to call callback function which will check the details before deleting the record

array_name = array_name.filter( (data) => data.id != id )

We are re-assigning the data based on the result of the filter condition



"Conditional Statements"

We use conditional statements to manipulate the data we show to the users. Let's say we have 2 
different users, "admin" and "end-user". Both of these users have access to "Facebook" yet 
when they log in, the "admin" is redirected to the admin page whereas the "end-user" is 
redirected to the other page like news feed and more so this is done by passing the input data
by these 2 users through some conditions and based on the conditions both users are taken to 
a different locations on the same application.

In svelte we use checks like "if checks" to apply conditions


"Components in svelte"

Normally a svelte website will have many components such as modal, header, footer, sidebar, navigation etc,
so we will have to make a tree where the root component will be the App.svelte and all other components are
linked with it in a tree like structure and the App.svelte will be injected in the dom by the main.js file.

By using a component tree, we can ensure that the distribution of out html is done the we want. The reasons
why we do this are because firstly we want to keep our code clean, easily readable and modular and since we 
have divided up our components, we can reuse them in other places we want.

When we make a new component and write the code, we need to import it in the App.svelte file so we do it by
going App.svelte and in the top inside the script tags we import the component

Example:

"Sample.svelte ------> component example"

"
<script>
	import Sample from './Sample.svelte';
</script>
"
The "Sample" is the name we have given to the component as a reference name 
so when we want to use this, we can write the reference name inside the self-closing
tags and that will bring the content of that component in the main App.svelte
file and it has to be outside the script tags and in the place where you want 
it to load.

// some code
"<Sample/>"
// some code


